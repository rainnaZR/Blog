<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title>ZRainna的博客-详情</title>
    <link type="text/css" rel="stylesheet" href="./css/base.css" />
    <link type="text/css" rel="stylesheet" href="./css/page.css" />
    <link type="text/css" rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.10.0/github-markdown.min.css" />
  </head>
  
  <body>
    <div class="m-page">
      <div class="m-box">
        <div class="m-introduce f-flexr">
    <div class="logo"><img src="https://avatars.githubusercontent.com/u/5309877"></div>
    <div class="f-ml25 f-flex-1">
        <p class="f-mb10 f-fs26">Zrainna</p>
        <p class="f-fs12 s-fc6">比较懒，什么都没介绍。。。。。</p>
    </div>
</div>
      </div>
      
      <div class="m-box">
        <div class="m-menu f-flexr f-mb40 f-fs16 f-tac">
    <div class="item"><a href="./index.html">首页</a></div>
    <div class="item"><a href="./article.html">文章</a></div>
    <div class="item"><a href="./book.html">书库</a></div>
    <div class="item"><a href="./demo.html">Demo</a></div>
</div>
        <div class="markdown-body"><h1>《ES6标准入门》之对象的扩展</h1><p>《ES6标准入门》阅读总结</p>
<h1 id="第八章-对象的扩展">第八章 对象的扩展</h1>
<h3 id="1-属性的简洁表示法">1. 属性的简洁表示法</h3>
<p>ES6允许直接写入变量和函数作为对象的属性和方法。</p>
<pre><code>{name, age}  //等于{name: name, age: age}

{
    getAge(){
        ...
    }
}</code></pre>
<h3 id="2-属性名表达式">2. 属性名表达式</h3>
<p>JS定义对象的属性有以下两种： </p>
<pre><code>obj.foo = true;  //属性名为标识符
obj[&#39;a&#39; + &#39;bc&#39;] = 123;  //属性名为表达式</code></pre>
<p>ES6可以使用表达式来定义：</p>
<pre><code>let foo = &#39;hello&#39;;
let obj = {
    [foo] : true,
    [&#39;a&#39; + &#39;bc&#39;] : 123,
    [&#39;fun&#39; + foo](){}
}
obj  
//{hello: true, abc: 123, funhello: ƒ}</code></pre>
<h3 id="3-objectis">3. Object.is()</h3>
<p>该方法比较两个值是否严格相等，与 === 基本一致。下面两种情况特殊：</p>
<pre><code>Object.is(NaN, NaN)  //true
NaN === NaN  //false

Object.is(+0, -0)  //false
+0 === -0   //true</code></pre>
<h3 id="4-objectassign">4. Object.assign()</h3>
<p>Object.assign(target, source)将原对象source的可枚举属性复制到目标对象target中。如果是嵌套重复的对象，则直接替换掉原有同名对象。</p>
<pre><code>var target = {a: 1, b:1};
var source1 = {b: 2, c:2};
var source2 = {c: 3};

Object.assign(target, source1, source2);

target  //{a: 1, b: 2, c: 3}</code></pre>
<p><strong>用处：</strong></p>
<p>1）给对象添加属性。</p>
<p>2）给对象添加方法。</p>
<p>3）克隆对象。</p>
<pre><code>function clone(origin){
    return Object.assign({}, origin);
}</code></pre>
<p>4）合并对象。</p>
<pre><code>function merge(target, ...source){
    return Object.assign(target, ...source)
}</code></pre>
<p>5）为属性指定默认值。</p>
<h3 id="5-属性的遍历">5. 属性的遍历</h3>
<p>ES5有3个操作会忽略对象中enumerabe为false的属性。</p>
<p>1）for...in循环。</p>
<p>2）Object.keys()。</p>
<p>3）JSON.stringify()。</p>
<p>ES6新增2个操作。</p>
<p>1）Object.assign()。</p>
<p>2）Reflect.enumerable()。返回所有for...in循环会遍历的属性。</p>
<p>ES6一共有6种方法遍历对象的属性。</p>
<p>1）for...in</p>
<p>2）Object.keys(obj)</p>
<p>3）Object.getOwnPropertyNames(obj)</p>
<p>4）Object.getOwnPropertySymbols(obj)</p>
<p>5）Reflect.ownKeys(obj)</p>
<p>6）Reflect.enumerable(obj)</p>
<h3 id="6-__proto__属性，objectsetprototypeof-objectgetprototypeof">6. __proto__属性，Object.setPrototypeOf(), Object.getPrototypeOf()</h3>
<p>__proto__读取当前对象的prototype对象。Object.setPrototypeOf()设置一个对象的prototype对象。</p>
<pre><code>//给obj设置原型链对象
Object.setPrototypeOf(obj, prototype);</code></pre>
<h3 id="7-对象的扩展运算符">7. 对象的扩展运算符</h3>
<pre><code>var {x, y, ...rest} = {x: 1, y:2, a: 3, b: 4}
rest
//输出{a: 3, b: 4}</code></pre>
<p>rest参数的复制是浅复制，不会复制原型对象上的属性。如果复制的是复合类型的值，则复制的是其引用，不是其副本。</p>
</div>
      </div>
    </div>
  </body>
</html>




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title>ZRainna的博客-详情</title>
    <link type="text/css" rel="stylesheet" href="./css/base.css" />
    <link type="text/css" rel="stylesheet" href="./css/page.css" />
    <link type="text/css" rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.10.0/github-markdown.min.css" />
  </head>
  
  <body>
    <div class="m-page">
      <div class="m-box">
        <div class="m-introduce f-flexr">
    <div class="logo"><img src="https://avatars.githubusercontent.com/u/5309877?s=460&v=4"></div>
    <div class="f-ml25 f-flex-1">
        <p class="f-mb10 f-fs26">Zrainna</p>
        <p class="f-fs12 s-fc6">比较懒，什么都没介绍。。。。。</p>
    </div>
</div>
      </div>
      
      <div class="m-box">
        <div class="m-menu f-flexr f-mb40 f-fs16 f-tac">
    <div class="item"><a href="./index.html">首页</a></div>
    <div class="item"><a href="./article.html">文章</a></div>
    <div class="item"><a href="./book.html">书库</a></div>
    <div class="item"><a href="./demo.html">Demo</a></div>
</div>
        
        <div class="markdown-body"><p>《现代前端技术解析》阅读总结</p>
<h1 id="第五章-前端项目与技术实践">第五章 前端项目与技术实践</h1>
<h3 id="1-前端开发规范">1. 前端开发规范</h3>
<p><strong>前端通用规范</strong></p>
<p>1）三层结构分离</p>
<p>2）缩进</p>
<p>3）内容编码utf-8</p>
<p>4）小写（属性名，样式名等）</p>
<p>5）代码单行长度限制</p>
<p>6）注释</p>
<p>7）行尾空格与符号</p>
<p>8）文档类型定义</p>
<pre><code>&lt;!DOCTYPE html&gt;</code></pre>
<p>9）head内容</p>
<p>head中定义title, keyword, description等关键字，移动端定义viewport关键字。</p>
<p>10）省略type属性</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./a.css&quot; /&gt;
&lt;script src=&quot;./base.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>11）双引号包裹属性值</p>
<pre><code>&lt;div class=&quot;m-list&quot;&gt;&lt;/div&gt;</code></pre>
<p>12）属性值省略</p>
<pre><code>&lt;input type=&quot;text&quot; disabled /&gt;</code></pre>
<p>13）合理嵌套，内联元素不可嵌套块状元素</p>
<p>14）标签闭合</p>
<p>15）img元素添加alt属性</p>
<p>16）label标签添加for属性</p>
<p>17）按模块添加注释</p>
<pre><code>&lt;!-- 列表模块 --&gt;
&lt;div class=&quot;m-list&quot;&gt;...&lt;/div&gt;
&lt;!-- 列表模块结束 --&gt;</code></pre>
<p>18）语义化标签</p>
<p>19）JS语句后统一加分号</p>
<p>20）添加必要的空格</p>
<p>21）JS变量命名驼峰式</p>
<p>22）字符串拼接使用字符串模板</p>
<p>23）解构赋值尽量使用一层结构</p>
<p>24）数组拷贝使用...实现</p>
<pre><code>let item = [2,3,4,5];
let item2 = [...item];</code></pre>
<p>25）数组循环优先使用for...of，代替forEach, map等。</p>
<pre><code>let arr = [2,3,4,5];
for(let item of arr){
    console.log(item);
}</code></pre>
<p>26）生成器中yield进行异步操作时使用try...catch进行包裹。</p>
<p><strong>前端防御性编程规范</strong></p>
<p>1）对模板中变量使用默认值，对前端提交的数据进行校验转义等。</p>
<p>2）对错误的规范化处理，比如接口超时，异常捕获等。</p>
<h3 id="2-前端组件规范">2. 前端组件规范</h3>
<p>前端主流的组件开发规范：UI组件规范，模块化规范（文件模块封装方式），项目组件规范（项目业务代码之间的组织形式）。</p>
<p><strong>UI组件规范</strong></p>
<p>1）UI设计一致性。相同功能的按钮在不用页面尽量设计保持一致等。</p>
<p>2）开发实现的一致性。统一的页面布局方案，基础UI结构的一致性，组件化的UI结构一致，响应式布局，组件的扩展等。</p>
<pre><code>@import

&quot;common/reset&quot;,
&quot;common/mixin&quot;,
&quot;common/variable&quot;,
&quot;common/icon-font&quot;,
&quot;common/rem&quot;;

&quot;fix/grid&quot;,
&quot;fix/animation&quot;,

&quot;component/btn&quot;,
&quot;component/form&quot;,
&quot;component/slider&quot;,
&quot;component/tab&quot;,
&quot;component/loading&quot;,
&quot;component/notice&quot;,
...</code></pre>
<p><strong>模块化规范</strong></p>
<p>主要包括AMD(Asynchronous Module Definition 异步模块定义)，CMD(Common Module Definition 通用模块定义)，CommonJs, import/export等。</p>
<p>1）AMD</p>
<p>AMD运行在浏览器端的模块化异步加载规范，以RequireJs为代表，基本原理是定义define和require方法异步请求对应的JS文件到浏览器端运行。模块导出时使用函数中的return返回结果。</p>
<pre><code>require(&#39;main&#39;, [&#39;./a.js&#39;, &#39;./b.js&#39;], function(A, B){
    A.init();
    B.init();
})</code></pre>
<p>2）CMD</p>
<p>CMD执行按需依赖的原则，在用到某个模块的时候才会执行模块内部的require语句，同时加载完某个依赖文件后并不会立即执行，在主模块逻辑运行语句的时候才会执行对应的模块。简而言之就是依赖的模块先加载不执行，只有等语句运行时才会执行依赖的模块。</p>
<pre><code>seajs.use([&#39;./a.js&#39;, &#39;./b.js&#39;], function(A, B){
    A.init();
    B.init();
})

//a.js
define(function(require, exports, module){
    let $ = require(&#39;zepto&#39;);

    module.exports = {
        init(){
            console.log(&#39;A&#39;);
        }
    };
})</code></pre>
<p>3）CommonJs</p>
<p>CommonJs模块用于Node端的JS规范，使用require进行模块引入，并使用module.exports定义模块导出。</p>
<pre><code>let A = require(&#39;./a.js&#39;),
    B = require(&#39;./b.js&#39;);

A.init();
B.init();

//a.js
const $ = require(&#39;zepto&#39;);

module.exports = {
    init(){
        console.log(&#39;A&#39;);
    }
}

//b.js
const $ = require(&#39;zepto&#39;);

module.exports = {
    init(){
        console.log(&#39;B&#39;);
    }
}</code></pre>
<p>4）import/export</p>
<p>import/export是es6定义的JS模块引用方式。使用import引入其他模块，使用export导出模块。</p>
<pre><code>import initA from &#39;./a.js&#39;;
import initB from &#39;./b.js&#39;;

initA();
initB();


//a.js
import Zepto as $ from &#39;zepto&#39;;

export default {
    initA(){
        console.log(&#39;A&#39;);
    }
}

//b.js
import Zepto as $ from &#39;zepto&#39;;

export default {
    initB(){
        console.log(&#39;B&#39;);
    }
}</code></pre>
<p>为了避免循环依赖的问题，会将已经加载的文件标识存入一个缓存数组中，下次如果重复引用则无需重复加载，直接引用缓存里模块的返回，然后依次运行加载的模块。</p>
<p><strong>项目组件化设计规范</strong></p>
<p>实现组件化的方案主要有：Web Component组件化，MVVM框架组件化，基于Virtual DOM框架的组件化，基于目录管理的组件化等。</p>
<p>1）Web Component组件化</p>
<p>基于Web Component组件化Polymer方案包括基础层（platform.js）,核心层（polymer.js）,元素层等。在HTML文档里注册生成组件的shadow dom。</p>
<p>2）MVVM框架组件化</p>
<p>将页面中的模块按文件划分，该组件的模板结构代码（MVVM语法），CSS样式，JS逻辑放在一个文件里。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;{{title}}&lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
...
&lt;/style&gt;

&lt;script&gt;
...
&lt;/script&gt;</code></pre>
<p>一个组件一个文件，通过构建或动态解析的方式动态获取该组件的CSS, HTML, JS并插入到页面上。</p>
<p>3）Virtual DOM组件化方案</p>
<p>比如reactJs代码为例：</p>
<pre><code>const React = require(&#39;react&#39;);
const ReactDOM = require(&#39;react-dom&#39;);
const styles = require(&#39;./mod.css&#39;);

let TextImage = React.createClass({
    render(){
        return (
            &lt;div&gt;{this.props.text}&lt;/div&gt;
        );
    }
})</code></pre>
<p>4）基于目录管理的通用组件</p>
<pre><code>/component
index.es  //组件逻辑处理
index.scss  //组件样式
index.html  //组件HTML结构
/img    //组件可能用到的静态图片</code></pre>
<p>5）总结</p>
<p>高效组件应该解决的问题：</p>
<ul>
<li>组件之间独立，松耦合；</li>
<li>组件间可以嵌套使用；</li>
<li>组件间通信，使用监听或观察者模式；</li>
<li>组件间公共部分抽离，组件自动构建打包；</li>
<li>异步组件和同步组件的分开处理；</li>
<li>组件继承和复用性；</li>
<li>私有组件的统一管理，通过搭建私有源实现；</li>
<li>方便的在新组件上进行扩展和自定义。</li>
</ul>
<h3 id="3-自动化构建">3. 自动化构建</h3>
<p>自动构建需要完成的事情有对文件进行模块化引入，依赖分析，资源合并，压缩优化，文件嵌入，路径替换，生成资源包等操作。</p>
<p><strong>自动化构建原理</strong></p>
<p>构建流程主要分为7个步骤：读取入口文件-&gt;分析模块引用-&gt;按照引用加载模块-&gt;模块文件编译处理-&gt;模块文件合并-&gt;文件优化处理-&gt;写入生成目录。</p>
<p><strong>构建工具需要解决的问题</strong></p>
<p>1）模块分析引入</p>
<p>JS组件模块文件的依赖分析过程，以require的方式为例：</p>
<ul>
<li>从入口模块开始分析require函数调用依赖；</li>
<li>根据依赖生成AST抽象语法树；</li>
<li>根据AST找到每个模块的模块名；</li>
<li>得到每个模块的依赖关系，生成依赖字典；</li>
<li>根据模块化引用机制包装每个模块，传入依赖字典以及import或require函数，生成执行的JS代码。</li>
</ul>
<p>2）模块化规范支持</p>
<p>比如ES6转换为ES5的语法等。</p>
<p>3）CSS编译，自动合并图片</p>
<p>4）HTML，JS，CSS资源压缩优化</p>
<p>HMTL内删除多余的注释和空格，CSS的压缩，JS的uglify操作。</p>
<p>5）HTML路径分析替换</p>
<p>6）区分开发和上线目录环境</p>
<p>7）异步文件打包方案</p>
<p>将非首屏的组件打包成异步资源，然后以异步的方式加载。</p>
<p>8）文件目录白名单设置</p>
<p>提供配置文件绕过不需要处理的文件目录等。</p>
<h3 id="4-前端性能优化">4. 前端性能优化</h3>
<p>用户的等待延时分为两部分：可控等待延时和不可控等待延时。可控等待延时可以优化，不可控等待延时很难优化，比如鼠标点击延时，CPU计算时间延时，ISP网络传输延时等。</p>
<p><strong>前端性能测试</strong></p>
<p>衡量页面性能主要通过以下指标：Performance Timing API, Profile 工具，页面埋点计时，资源加载时序图分析。</p>
<p>1）Performance Timing API</p>
<p>浏览器加载一个HTML文件，先后会经历unload, redirect, APP Cache, DNS, TCP, Request, Response, Processing, onload几个阶段。</p>
<p>2）Profile工具</p>
<p>结合Profile，可以实现以下几个功能：</p>
<ul>
<li>分析页面脚本执行过程中最耗资源的操作。</li>
<li>页面脚本执行过程中JS对象消耗的内存和堆栈使用情况。</li>
<li>检测页面脚本执行过程中CPU占用情况。</li>
</ul>
<p>使用console.profile()和console.profileEnd()可以分析中间一段代码执行时系统内存或CPU资源的消耗情况。</p>
<p>3）页面埋点计时</p>
<p>在JS代码中添加埋点，通过计算差值得出某个操作的耗时。常常用于移动端，将关键JS的埋点计时及时上报，找出JS执行慢的地方，并有针对性的优化。</p>
<p>4）资源加载时序图</p>
<p>保证CSS和关键性数据请求优先加载，页面中非关键性图片延后加载等。通过查看资源文件的加载顺序和加载时长，找出加载过程中耗时较长的文件，并优化。</p>
<p><strong>PC端前端优化策略</strong></p>
<p>总结起来主要有：网络加载类，页面渲染类，CSS优化类，JS执行类，缓存类，图片类，架构协议等。</p>
<p>1）网络加载类</p>
<ul>
<li>减少HTTP请求次数，文件合并等；</li>
<li>减少HTTP请求大小，使用文件压缩等；</li>
<li>CSS和JS文件外部引入，可以用到浏览器缓存；</li>
<li>避免页面中空的href和src属性，因为无效的资源文件会阻塞页面中其他资源的下载；</li>
<li>为HTML指定Cache-Control或Expires；</li>
<li>合理设置Etag和Last-Modified；</li>
<li>减少页面重定向；</li>
<li>使用域名发散策略增加下载并行数；</li>
<li>使用CDN缓存静态文件；</li>
<li>使用CDN Combo合并文件；</li>
<li>使用缓存的Ajax；</li>
<li>减少Cookie大小，保持Cookie隔离，使用不同域名来请求，因为Cookie默认不跨域；</li>
<li>异步加载JS资源；</li>
<li>消除阻塞渲染的CSS和JS，保证关键路径的资源能快速加载。</li>
</ul>
<p>2）页面渲染类</p>
<ul>
<li>将CSS资源放到HTML文件头部。</li>
<li>JS放到HTML文件尾部。</li>
<li>不在HTML中缩放图片。</li>
<li>减少DOM元素数量和深度。</li>
<li>避免使用table, iframe等慢元素。table内容是将DOM渲染树生成完一次性绘制到页面上的。iframe内资源的下载会阻塞父页面其他资源的下载。</li>
<li>运行耗时的JS试用异步加载。</li>
</ul>
<p><strong>移动端前端优化策略</strong></p>
<p>移动端浏览器的特点：支持较新的HTML5和CSS3新特性，与Native进行交互等。</p>
<p>1）网络加载类</p>
<ul>
<li>首屏数据提前，比如后端同步给出等。</li>
<li>首屏内容最小化，首屏加载和按需加载，非首屏内容则滚动加载。</li>
<li>模块化资源并行下载。</li>
<li>inline首屏必备的CSS和JS。</li>
<li>DNS预加载和预解析，使用meta标签设置。</li>
<li>资源预加载，首屏加载完成后自动去加载非首屏资源，等用户浏览时资源已加载完成。</li>
</ul>
<p>2）缓存类</p>
<ul>
<li>合理利用浏览器缓存。比如cache-control, expires, max-age, Etag, Last-Modified设置HTTP缓存，还可以使用浏览器本地的localstorage, cookie等。</li>
<li>静态资源离线方案。APP内设置离线文件或离线包机制，从本地读取静态资源。</li>
<li>尝试使用AMP HTML.</li>
</ul>
<p>3）图片类</p>
<ul>
<li>图片压缩处理，不要使用原图。</li>
<li>较小的图片使用base64处理等。</li>
<li>使用iconfont代替图片图标。</li>
<li>使用webp格式的图片。</li>
<li>图片懒加载。</li>
<li>不同屏幕不同分辨率的屏幕设备加载不同尺寸的图片。</li>
<li>图片大小做限制。如果用户上传图片过大，则提醒警告等。</li>
</ul>
<p>4）脚本类</p>
<ul>
<li>使用ID类选择器。</li>
<li>合理缓存DOM对象。</li>
<li>使用事件委托。</li>
<li>使用touchstart事件代替click事件，注意穿透问题。</li>
<li>使用事件节流和延时策略。</li>
<li>使用ES6新特性来编程。</li>
<li>使用字符串模板实现代码的拼接。</li>
</ul>
<p>5）渲染类</p>
<ul>
<li>移动端定义视口设置。</li>
<li>避免各种形式的重排重绘。例如页面图片大小变化，元素位置变化等都会触发重排重绘。</li>
<li>使用CSS3动画，开启GPU加速。</li>
<li>合理使用canvas和requestAnimationFrame。</li>
<li>SVG代替图片。</li>
<li>使用flex弹性布局。</li>
<li>不滥用web字体。</li>
</ul>
<p>6）架构协议类</p>
<ul>
<li>尝试使用SPDY和HTTP2。</li>
<li>使用后端数据渲染。</li>
<li>使用Native View代替DOM。</li>
</ul>
<h3 id="5-前端用户数据分析">5. 前端用户数据分析</h3>
<p><strong>用户访问统计</strong></p>
<p>页面访问统计主要包括：PV(Page View), UV(Unique Visitor用户数), VV(Visit View), IP等。</p>
<p>可以根据UV统计出站点的周活跃量和月活跃用户量。可以根据浏览器Cookie和IP，加上UV统计，也可以通过用户浏览器UA和IP，加上UV统计。</p>
<p><strong>用户行为分析</strong></p>
<p>一般分析用户行为的指标有：页面点击量，用户点击流，用户访问路径，用户点击热力图，用户转换率，用户访问时长，用户访问内容分析等。</p>
<p>1）页面点击量，分析用户对哪部分内容最感兴趣。</p>
<p>2）用户点击流分析，反应用户在页面上的操作行为。</p>
<p>3）用户访问路径分析，对用户访问的不同页面进行埋点。</p>
<p>4）用户点击热力图，统计用户的操作习惯，以及页面中哪部分内容受用户关注。统计方式是捕获鼠标事件在屏幕中的坐标位置进行上报，然后在服务端计算归类分析并绘图。</p>
<pre><code>$(document).on(&#39;click&#39;, &#39;body&#39;, function(e){
    report(e.pageX, e.pageY);
})</code></pre>
<p>5）用户转化率与导流转化率。</p>
<p>6）用户访问时长，内容分析。</p>
<p><strong>前端日志上报</strong></p>
<p>1）使用try...cache和window.onerror获取错误日志。window.onerror有跨域限制。</p>
<pre><code>window.onerror = function(msg, url, line){
    console.log(msg);  //获取错误信息
    console.log(url); //出错的文件路径
    console.log(line);  //出错的行数
}</code></pre>
<p>2）将错误信息以HTTP请求的方式上传到服务器。</p>
<h3 id="6-seo优化">6. SEO优化</h3>
<p>1）meta里正确设置title, keywords, description。</p>
<p>2）html标签语义化。</p>
</div>
      </div>
    </div>
  </body>
</html>




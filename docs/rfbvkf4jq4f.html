<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title>ZRainna的博客-详情</title>
    <link type="text/css" rel="stylesheet" href="./css/base.css" />
    <link type="text/css" rel="stylesheet" href="./css/page.css" />
    <link type="text/css" rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.10.0/github-markdown.min.css" />
  </head>
  
  <body>
    <div class="m-page">
      <div class="m-box">
        <div class="m-introduce f-flexr">
    <div class="logo"><img src="https://avatars.githubusercontent.com/u/5309877?s=460&v=4"></div>
    <div class="f-ml25 f-flex-1">
        <p class="f-mb10 f-fs26">Zrainna</p>
        <p class="f-fs12 s-fc6">比较懒，什么都没介绍。。。。。</p>
    </div>
</div>
      </div>
      
      <div class="m-box">
        <div class="m-menu f-flexr f-mb40 f-fs16 f-tac">
    <div class="item"><a href="./index.html">首页</a></div>
    <div class="item"><a href="./article.html">文章</a></div>
    <div class="item"><a href="./book.html">书库</a></div>
    <div class="item"><a href="./demo.html">Demo</a></div>
</div>
        
        <div class="markdown-body"><h1>《js设计模式》之面向对象编程-写的都是看到的</h1><h1 id="《js设计模式》之面向对象编程-写的都是看到的">《js设计模式》之面向对象编程-写的都是看到的</h1>
<h2 id="1-面向过程和面向对象">1. 面向过程和面向对象</h2>
<p>面向对象编程就是将需求抽象成对象，然后针对这个对象分析其特征（属性）和动作（方法）。这个对象就叫类。面向对象编程有个特点就是封装，将需要的功能放在一个对象里。</p>
<h2 id="2-封装">2. 封装</h2>
<p>将代表类的变量名首字母大写， 在这个类的内部通过this变量添加属性和方法来进行扩展。通过this定义的属性和方法是该对象自身拥有的，通过prototype继承的属性和方法是每个对象通过prototype访问到，创建一次就可以了。</p>
<pre><code>var Book = function(id, bookname, price){
  this.id = id;
  this.bookname = bookname,
  this.price = price;
}</code></pre>
<p>由于js的函数级作用域，声明在函数内部的变量以及方法在外部是访问不到的，这样就创建了类的私有变量及私有方法。
在函数内部通过this创建的属性和方法，在类创建对象时，每个对象自身拥有这些数据且能在外部通过this访问到，这种称为对象共有属性和共有方法。</p>
<pre><code>var Book = function(id, name, price){
  //私有属性
  var num = 1;
  //私有方法
  function checkId(){};
  //特权方法
  this.getName = function(){};
  this.getPrice = function(){};
  this.setName = function(){};
  //对象公有属性
  this.id = id;
  //对象公有方法
  this.copy = function(){};
  //构造器
  this.setName(name);
  this.setPrice(price);
}</code></pre>
<p>通过new关键字创建的对象实质是对新对象this的不断赋值，并将新对象的prototype指向类的prototype对象，新对象的prototye和类的prototype指向同一个对象。new的关键字是给this赋值的，如果少了new，则赋值会到全局window上。</p>
<p>闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另一个函数。 </p>
<h2 id="3-继承">3. 继承</h2>
<p>每个类有三个部分：</p>
<ul>
<li>构造函数内的，供实例化对象复制用的。</li>
<li>构造函数外的，通过点语法添加的，供类使用的。</li>
<li>类的原型中的，可以通过原型链来间接访问。</li>
</ul>
<h3 id="31-类式继承">3.1 类式继承</h3>
<h4 id="原理：">原理：</h4>
<p>实例化一个父类时，新创建的对象不仅可以访问父类原型上的属性和方法，还可以访问父类构造函数中复制的属性和方法。instanceof通过判断对象的prototype链来确定这个对象是否是某个类的实例。</p>
<h4 id="缺陷：">缺陷：</h4>
<ol>
<li>子类通过原型prototype对父类实例化，所有的子类都会继承父类的方法和属性，如果父类中的属性是引用类型时，则一个子类的更改会影响所有的其他子类。</li>
<li>子类的继承是靠其prototype对父类的实例化来实现的，因此不能向父类传递参数。</li>
</ol>
<h3 id="32-构造函数继承">3.2 构造函数继承</h3>
<p>使用call, apply方法来实现构造函数的继承。</p>
<h3 id="33-组合继承">3.3 组合继承</h3>
<p>类式继承是通过子类的原型prototype等于实例化的父类来实现的。构造函数继承是通过在子类的构造函数中通过apply/call方法来执行一次父类的构造函数。</p>
<pre><code>// 声明父类
function SuperClass(name){
  this.name = name;
}
// 父类原型共有方法
SuperClass.prototype.getName = function(){};

// 声明子类
funciton SubClass(name){
  // 构造函数继承
  SuperClass.call(this, name);
}
// 类式继承
SubClass.prototype = new SuperClass();</code></pre>
<p>继承是对原有对象对封装，从中创建私有属性，私有方法，特权方法，共有属性，共有方法。等。原型链继承等方式叫类式继承，通过构造函数继承的方式叫构造函数继承。</p>
</div>
      </div>
    </div>
  </body>
</html>



